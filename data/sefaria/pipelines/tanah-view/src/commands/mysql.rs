//! Generate MySQL SQL file from MongoDB aggregation.
//!
//! Generates INSERT statements for tanah_helek, tanah_sefer, tanah_additional,
//! tanah_perek, and tanah_perek_date tables.

use anyhow::Result;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

use crate::models::{Perek, Sefer};

pub fn generate(
    sefarim: &[Sefer],
    dump_name: &str,
    output_to_dependant_modules: bool,
) -> Result<()> {
    let output_path = if output_to_dependant_modules {
        // Output to data/mysql/ directory
        Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("../../../mysql")
            .join("tanah_sefarim_and_perakim_data.sql")
    } else {
        let outputs_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join(".output");
        fs::create_dir_all(&outputs_dir)?;
        outputs_dir.join(format!("{}.tanah_sefarim_and_perakim_data.sql", dump_name))
    };

    generate_sql(&output_path, sefarim, dump_name)?;
    println!("ğŸ“ Written to: {}", output_path.display());

    Ok(())
}

fn generate_sql(path: &Path, sefarim: &[Sefer], dump_name: &str) -> Result<()> {
    let mut sql = String::new();

    // Header
    sql.push_str("-- Generated by: cd data && cargo make generate-tanah-view-mysql\n");
    sql.push_str(&format!("-- Source: {}\n", dump_name));
    sql.push_str(&format!(
        "-- Generated at: {}\n\n",
        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    sql.push_str("USE `tanah_test`;\n\n");

    // Disable foreign key checks for faster inserts
    sql.push_str("SET FOREIGN_KEY_CHECKS = 0;\n\n");

    // Generate helek data
    generate_helek_sql(&mut sql, sefarim);

    // Generate sefer data
    generate_sefer_sql(&mut sql, sefarim);

    // Generate additional data
    generate_additional_sql(&mut sql, sefarim);

    // Generate perek data
    generate_perek_sql(&mut sql, sefarim);

    // Generate perek_date data
    generate_perek_date_sql(&mut sql, sefarim);

    // Re-enable foreign key checks
    sql.push_str("\nSET FOREIGN_KEY_CHECKS = 1;\n");

    fs::write(path, sql)?;

    Ok(())
}

fn escape_sql_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('\'', "\\'")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn generate_helek_sql(sql: &mut String, sefarim: &[Sefer]) {
    sql.push_str("-- tanah_helek\n");

    let helek_map: HashMap<&str, i64> = [("×ª×•×¨×”", 1), ("× ×‘×™××™×", 2), ("×›×ª×•×‘×™×", 3)]
        .into_iter()
        .collect();

    // Calculate sefer ranges per helek
    let mut helek_ranges: HashMap<i64, (i64, i64)> = HashMap::new();

    for (sefer_idx, sefer) in sefarim.iter().enumerate() {
        let sefer_id = (sefer_idx + 1) as i64;
        let helek_id = helek_map.get(sefer.helek.as_str()).copied().unwrap_or(1);

        helek_ranges
            .entry(helek_id)
            .and_modify(|(from, to)| {
                if sefer_id < *from {
                    *from = sefer_id;
                }
                if sefer_id > *to {
                    *to = sefer_id;
                }
            })
            .or_insert((sefer_id, sefer_id));
    }

    for (name, id) in &helek_map {
        if let Some((from, to)) = helek_ranges.get(id) {
            sql.push_str(&format!(
                "INSERT INTO tanah_helek (id, name, sefer_id_from, sefer_id_to) VALUES ({}, '{}', {}, {});\n",
                id, escape_sql_string(name), from, to
            ));
        }
    }
    sql.push('\n');
}

fn generate_sefer_sql(sql: &mut String, sefarim: &[Sefer]) {
    sql.push_str("-- tanah_sefer\n");

    for (sefer_idx, sefer) in sefarim.iter().enumerate() {
        let sefer_id = sefer_idx + 1;
        let tanach_us_name = sefer
            .tanach_us_name
            .as_deref()
            .map(|s| format!("'{}'", escape_sql_string(s)))
            .unwrap_or_else(|| "NULL".to_string());

        sql.push_str(&format!(
            "INSERT INTO tanah_sefer (id, name, tanach_us_name, perek_id_from, perek_id_to) VALUES ({}, '{}', {}, {}, {});\n",
            sefer_id,
            escape_sql_string(&sefer.name),
            tanach_us_name,
            sefer.perek_from,
            sefer.perek_to
        ));
    }
    sql.push('\n');
}

fn generate_additional_sql(sql: &mut String, sefarim: &[Sefer]) {
    sql.push_str("-- tanah_additional\n");

    for (sefer_idx, sefer) in sefarim.iter().enumerate() {
        let sefer_id = sefer_idx + 1;

        if let Some(additionals) = &sefer.additionals {
            for additional in additionals {
                let tanach_us_name = additional.tanach_us_name.as_deref().unwrap_or("");

                sql.push_str(&format!(
                    "INSERT INTO tanah_additional (sefer_id, letter, tanach_us_name, perek_from, perek_to) VALUES ({}, '{}', '{}', {}, {});\n",
                    sefer_id,
                    escape_sql_string(&additional.letter),
                    escape_sql_string(tanach_us_name),
                    additional.perek_from,
                    additional.perek_to
                ));
            }
        }
    }
    sql.push('\n');
}

fn collect_all_perakim(sefarim: &[Sefer]) -> Vec<&Perek> {
    let mut all_perakim = Vec::new();

    for sefer in sefarim {
        if let Some(perakim) = &sefer.perakim {
            all_perakim.extend(perakim.iter());
        }
        if let Some(additionals) = &sefer.additionals {
            for additional in additionals {
                all_perakim.extend(additional.perakim.iter());
            }
        }
    }

    all_perakim
}

fn generate_perek_sql(sql: &mut String, sefarim: &[Sefer]) {
    sql.push_str("-- tanah_perek\n");

    let all_perakim = collect_all_perakim(sefarim);

    for perek in &all_perakim {
        sql.push_str(&format!(
            "INSERT INTO tanah_perek (id, perek, header) VALUES ({}, {}, '{}');\n",
            perek.perek_id,
            perek.perek_id,
            escape_sql_string(&perek.header)
        ));
    }
    sql.push('\n');
}

fn hebdate_to_mysql_date(hebdate: i64) -> String {
    // Convert YYYYMMDD Hebrew date format to a Gregorian-ish date for MySQL
    // For now, just store as a string date (the actual date conversion would need
    // Hebrew calendar conversion which is complex)
    // Format: YYYY-MM-DD where we use the Hebrew year directly
    let year = hebdate / 10000;
    let month = (hebdate % 10000) / 100;
    let day = hebdate % 100;

    // Use a fixed year range for MySQL DATE type (MySQL requires valid dates)
    // Map Hebrew year 5775-5799 to 2014-2038 (approximately)
    let greg_year = if year >= 5775 && year <= 5799 {
        year - 3761 // Approximate Hebrew to Gregorian
    } else {
        2024 // Default fallback
    };

    format!(
        "{:04}-{:02}-{:02}",
        greg_year,
        month.min(12).max(1),
        day.min(28).max(1)
    )
}

fn generate_perek_date_sql(sql: &mut String, sefarim: &[Sefer]) {
    sql.push_str("-- tanah_perek_date\n");

    let all_perakim = collect_all_perakim(sefarim);

    for perek in &all_perakim {
        for (cycle_idx, date_val) in perek.date.iter().enumerate() {
            let cycle = cycle_idx + 1;
            let star_rise = perek
                .star_rise
                .get(cycle_idx)
                .map(|s| s.as_str())
                .unwrap_or("00:00");

            // Format star_rise as TIME (HH:MM:SS)
            let star_rise_time = if star_rise.len() == 5 {
                format!("{}:00", star_rise)
            } else {
                star_rise.to_string()
            };

            sql.push_str(&format!(
                "INSERT INTO tanah_perek_date (perek_id, cycle, date, hebdate, star_rise) VALUES ({}, {}, '{}', '{}', '{}');\n",
                perek.perek_id,
                cycle,
                hebdate_to_mysql_date(*date_val),
                date_val,
                star_rise_time
            ));
        }
    }
    sql.push('\n');
}

name: App Package Flow
on:
  workflow_dispatch:
    inputs:
      platform:
        description: "Target platform: Windows, Android, iOS, or All"
        required: false
        type: choice
        options:
          - All
          - Windows
          - Android
          - iOS
        default: "All"
      perushim_notes_sqlite_artifact:
        description: "Artifact name for perushim notes SQLite (leave empty for .gz fallback)"
        required: false
        type: string
        default: ""
  workflow_call:
    inputs:
      platform:
        description: "Target platform: Windows, Android, iOS, or All"
        required: false
        type: string
        default: "All"
      perushim_notes_sqlite_artifact:
        description: "Artifact name for perushim notes SQLite (leave empty for .gz fallback)"
        required: false
        type: string
        default: ""
    secrets:
      WINDOWS_SIGNING_CERT_BASE64:
        required: false
      WINDOWS_SIGNING_CERT_PASSWORD:
        required: false
      WINDOWS_SIGNING_CERT_THUMBPRINT:
        required: false
      ANDROID_KEYSTORE_BASE64:
        required: false
      ANDROID_KEYSTORE_PASSWORD:
        required: false
      ANDROID_KEY_ALIAS:
        required: false
      ANDROID_KEY_PASSWORD:
        required: false
      IOS_CERTIFICATE_BASE64:
        required: false
      IOS_CERTIFICATE_PASSWORD:
        required: false
      IOS_PROVISIONING_PROFILE_BASE64:
        required: false
      IOS_TEAM_ID:
        required: false
    outputs:
      module_version:
        description: The version of the app.
        value: ${{ jobs.package_android.outputs.module_version || jobs.package_windows.outputs.module_version || jobs.package_ios.outputs.module_version }}
      windows_artifact_name:
        description: The name of the Windows MSIX artifact.
        value: ${{ jobs.package_windows.outputs.artifact_name }}
      android_artifact_name:
        description: The name of the Android AAB artifact.
        value: ${{ jobs.package_android.outputs.artifact_name }}
      ios_artifact_name:
        description: The name of the iOS IPA artifact.
        value: ${{ jobs.package_ios.outputs.artifact_name }}

permissions:
  contents: read

env:
  APP_DIRECTORY: app
  PERUSHIM_NOTES_SQLITE_FILENAME: sefaria-dump-5784-sivan-4.perushim_notes.sqlite
  PERUSHIM_NOTES_ANDROID_ASSET_RELDIR: Platforms/Android/AssetPacks/perushim_notes
  PERUSHIM_NOTES_IOS_ODR_DATASET_RELDIR: Platforms/iOS/Assets/PerushimNotes.xcassets/perushim_notes.dataset

jobs:
  package_windows:
    name: Package Windows (MSIX)
    if: ${{ inputs.platform == 'Windows' || inputs.platform == 'All' }}
    runs-on: windows-latest
    outputs:
      artifact_name: ${{ steps.set_artifact_name.outputs.artifact_name }}
      module_version: ${{ steps.get_version.outputs.VERSION }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get .NET version and app version from csproj
        id: get_version
        working-directory: ${{ env.APP_DIRECTORY }}
        shell: pwsh
        run: |
          $content = Get-Content BibleOnSite/BibleOnSite.csproj -Raw
          # Extract .NET version
          if ($content -match 'net(\d+\.\d+)') {
            $dotnetVersion = "$($Matches[1]).x"
            echo "DOTNET_VERSION=$dotnetVersion" >> $env:GITHUB_OUTPUT
            echo ".NET version: $dotnetVersion"
          }
          # Extract ApplicationDisplayVersion
          if ($content -match '<ApplicationDisplayVersion>([^<]+)</ApplicationDisplayVersion>') {
            $version = $Matches[1]
            echo "VERSION=$version" >> $env:GITHUB_OUTPUT
            echo "App version: $version"
          }

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ steps.get_version.outputs.DOTNET_VERSION }}

      - name: Cache NuGet packages
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-maui-windows-${{ hashFiles('app/**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-maui-windows-
            ${{ runner.os }}-nuget-

      - name: Install MAUI workload
        run: dotnet workload install maui-windows --skip-manifest-update

      - name: Decode signing certificate
        run: |
          $certBytes = [Convert]::FromBase64String("${{ secrets.WINDOWS_SIGNING_CERT_BASE64 }}")
          [IO.File]::WriteAllBytes("${{ runner.temp }}\SigningCert.pfx", $certBytes)

          # Import certificate to store
          $password = ConvertTo-SecureString -String "${{ secrets.WINDOWS_SIGNING_CERT_PASSWORD }}" -Force -AsPlainText
          Import-PfxCertificate -FilePath "${{ runner.temp }}\SigningCert.pfx" -CertStoreLocation Cert:\CurrentUser\My -Password $password
        shell: pwsh

      - name: Restore dotnet tools
        working-directory: ${{ env.APP_DIRECTORY }}
        run: dotnet tool restore

      - name: Package MSIX
        working-directory: ${{ env.APP_DIRECTORY }}
        run: |
          dotnet run --project devops -- Package --platform Windows --configuration Release --certificate-thumbprint "${{ secrets.WINDOWS_SIGNING_CERT_THUMBPRINT }}"

      - name: Find MSIX file
        id: find_msix
        run: |
          $msix = Get-ChildItem -Path "${{ env.APP_DIRECTORY }}/.artifacts" -Filter "*.msix" -Recurse | Select-Object -First 1
          if ($msix) {
            echo "Found .msix file"
            echo "MSIX_PATH=$($msix.FullName)" >> $env:GITHUB_OUTPUT
            echo "MSIX_NAME=$($msix.Name)" >> $env:GITHUB_OUTPUT
          } else {
            $upload = Get-ChildItem -Path "${{ env.APP_DIRECTORY }}/.artifacts" -Filter "*.msixupload" -Recurse | Select-Object -First 1
            if ($upload) {
              echo "Found .msixupload file"
              echo "MSIX_PATH=$($upload.FullName)" >> $env:GITHUB_OUTPUT
              echo "MSIX_NAME=$($upload.Name)" >> $env:GITHUB_OUTPUT
            } else {
              echo "No MSIX or MSIXUPLOAD file found!"
            }
          }
        shell: pwsh

      - name: Set artifact name output
        id: set_artifact_name
        run: echo "artifact_name=app-windows-v${{ steps.get_version.outputs.VERSION }}" >> $GITHUB_OUTPUT
        shell: bash

      - name: Upload MSIX artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.set_artifact_name.outputs.artifact_name }}
          path: ${{ env.APP_DIRECTORY }}/.artifacts/*
          retention-days: 30
          if-no-files-found: error
          include-hidden-files: true

      - name: Cleanup certificate
        if: always()
        run: |
          if (Test-Path "${{ runner.temp }}\SigningCert.pfx") {
            Remove-Item "${{ runner.temp }}\SigningCert.pfx" -Force
          }
        shell: pwsh

  package_android:
    name: Package Android (AAB)
    if: ${{ inputs.platform == 'Android' || inputs.platform == 'All' }}
    runs-on: ubuntu-latest
    outputs:
      artifact_name: ${{ steps.set_artifact_name.outputs.artifact_name }}
      module_version: ${{ steps.get_version.outputs.VERSION }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get .NET version and app version from csproj
        id: get_version
        working-directory: ${{ env.APP_DIRECTORY }}
        run: |
          # Extract .NET version from TargetFrameworks
          DOTNET_VERSION=$(grep -oP 'net\K[0-9]+\.[0-9]+' BibleOnSite/BibleOnSite.csproj | head -1)
          echo "DOTNET_VERSION=${DOTNET_VERSION}.x" >> $GITHUB_OUTPUT
          echo ".NET version: ${DOTNET_VERSION}.x"
          # Extract ApplicationDisplayVersion
          VERSION=$(grep -oP '<ApplicationDisplayVersion>\K[^<]+' BibleOnSite/BibleOnSite.csproj)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "App version: $VERSION"

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ steps.get_version.outputs.DOTNET_VERSION }}

      - name: Setup Java
        uses: actions/setup-java@v5
        with:
          distribution: "microsoft"
          java-version: "17"

      - name: Cache NuGet packages
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-maui-android-${{ hashFiles('app/**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-maui-android-
            ${{ runner.os }}-nuget-

      - name: Install MAUI workload
        run: dotnet workload install maui-android --skip-manifest-update

      - name: Restore perushim notes SQLite for AAB asset pack
        if: ${{ inputs.perushim_notes_sqlite_artifact != '' }}
        id: restore_perushim_android
        continue-on-error: true
        uses: actions/download-artifact@v7
        with:
          name: ${{ inputs.perushim_notes_sqlite_artifact }}
          path: ${{ env.APP_DIRECTORY }}/BibleOnSite/${{ env.PERUSHIM_NOTES_ANDROID_ASSET_RELDIR }}

      - name: Decompress perushim notes for AAB asset pack (fallback)
        if: ${{ inputs.perushim_notes_sqlite_artifact == '' || steps.restore_perushim_android.outcome == 'failure' }}
        working-directory: ${{ env.APP_DIRECTORY }}/BibleOnSite
        run: |
          GZ_FILE="${{ env.PERUSHIM_NOTES_ANDROID_ASSET_RELDIR }}/${{ env.PERUSHIM_NOTES_SQLITE_FILENAME }}.gz"
          if [ -f "$GZ_FILE" ] && [ ! -f "${GZ_FILE%.gz}" ]; then
            gunzip -k "$GZ_FILE"
            echo "::warning::Using .gz fallback — SQLite artifact not available"
            echo "Decompressed perushim notes ($(du -h "${GZ_FILE%.gz}" | cut -f1))"
          else
            echo "Perushim notes already decompressed or .gz not found — skipping"
          fi

      - name: Decode Android keystore
        run: |
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 --decode > ${{ runner.temp }}/keystore.jks
          echo "ANDROID_KEYSTORE_PATH=${{ runner.temp }}/keystore.jks" >> $GITHUB_ENV

      - name: Restore dotnet tools
        working-directory: ${{ env.APP_DIRECTORY }}
        run: dotnet tool restore

      - name: Package AAB
        working-directory: ${{ env.APP_DIRECTORY }}
        run: |
          if [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ]; then
            dotnet run --project devops -- Package --platform Android --configuration Release \
              --android-keystore "${{ env.ANDROID_KEYSTORE_PATH }}" \
              --android-keystore-password "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" \
              --android-key-alias "${{ secrets.ANDROID_KEY_ALIAS }}" \
              --android-key-password "${{ secrets.ANDROID_KEY_PASSWORD }}"
          else
            dotnet run --project devops -- Package --platform Android --configuration Release
          fi

      - name: Set artifact name output
        id: set_artifact_name
        run: echo "artifact_name=app-android-v${{ steps.get_version.outputs.VERSION }}" >> $GITHUB_OUTPUT

      - name: Upload AAB artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.set_artifact_name.outputs.artifact_name }}
          path: ${{ env.APP_DIRECTORY }}/.artifacts/*.aab
          retention-days: 30
          if-no-files-found: error
          include-hidden-files: true

      - name: Cleanup keystore
        if: always()
        run: |
          if [ -f "${{ runner.temp }}/keystore.jks" ]; then
            rm -f "${{ runner.temp }}/keystore.jks"
          fi

  package_ios:
    name: Package iOS (IPA)
    if: ${{ inputs.platform == 'iOS' || inputs.platform == 'All' }}
    runs-on: macos-15
    outputs:
      artifact_name: ${{ steps.set_artifact_name.outputs.artifact_name }}
      module_version: ${{ steps.get_version.outputs.VERSION }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get .NET version and app version from csproj
        id: get_version
        working-directory: ${{ env.APP_DIRECTORY }}
        run: |
          # Extract .NET version from TargetFrameworks
          DOTNET_VERSION=$(grep -oE 'net[0-9]+\.[0-9]+' BibleOnSite/BibleOnSite.csproj | head -1 | sed 's/net//')
          echo "DOTNET_VERSION=${DOTNET_VERSION}.x" >> $GITHUB_OUTPUT
          echo ".NET version: ${DOTNET_VERSION}.x"
          # Extract ApplicationDisplayVersion
          VERSION=$(grep -oE '<ApplicationDisplayVersion>[^<]+</ApplicationDisplayVersion>' BibleOnSite/BibleOnSite.csproj | sed 's/<[^>]*>//g')
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "App version: $VERSION"

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ steps.get_version.outputs.DOTNET_VERSION }}

      - name: Cache NuGet packages
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-maui-ios-${{ hashFiles('app/**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-maui-ios-
            ${{ runner.os }}-nuget-

      - name: Install MAUI workload
        run: |
          # Show .NET SDK info to debug
          dotnet --info
          # Install the MAUI iOS workload
          dotnet workload install maui-ios --skip-manifest-update
          # Show installed workloads
          dotnet workload list

      - name: Select Xcode version
        run: |
          # List available Xcode versions
          echo "Available Xcode installations:"
          ls -la /Applications/ | grep -i xcode || true

          # The MAUI iOS workload installs iOS SDK 26.0.9766 which requires exactly Xcode 26.0
          # Using Xcode 26.1 or 26.2 causes: "requires Xcode 26.0. The current version of Xcode is 26.2"
          # Find Xcode 26.0.x installation specifically
          XCODE_PATH=$(ls -d /Applications/Xcode_26.0*.app 2>/dev/null | sort -V | tail -1)
          if [ -z "$XCODE_PATH" ]; then
            # Fallback to any 26.x if 26.0.x not found
            echo "Xcode 26.0.x not found, trying any 26.x"
            XCODE_PATH=$(ls -d /Applications/Xcode_26*.app 2>/dev/null | sort -V | head -1)
          fi
          if [ -z "$XCODE_PATH" ]; then
            # Fallback to default Xcode
            echo "Xcode 26.x not found, using default Xcode"
            XCODE_PATH=$(xcode-select -p | sed 's|/Contents/Developer||')
          fi

          echo "Selecting Xcode: $XCODE_PATH"
          sudo xcode-select -s "$XCODE_PATH/Contents/Developer"

          echo "Selected Xcode path:"
          xcode-select -p
          # Show Xcode version
          echo "Xcode version:"
          xcodebuild -version

      - name: Install compatible iOS simulator runtime
        run: |
          echo "Current simulator runtimes:"
          xcrun simctl list runtimes
          echo ""
          # The .NET iOS SDK uses iphonesimulator SDK 23A339 which requires a compatible runtime
          # The pre-installed runtimes (iOS 18.x/26.x) aren't compatible - download one that is
          echo "Downloading compatible iOS simulator runtime..."
          xcodebuild -downloadPlatform iOS 2>/dev/null || echo "Download completed or not needed"
          echo ""
          echo "Updated simulator runtimes:"
          xcrun simctl list runtimes

      - name: Setup iOS signing
        env:
          CERTIFICATE_BASE64: ${{ secrets.IOS_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.IOS_CERTIFICATE_PASSWORD }}
          PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Decode and import certificate
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo -n "$CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Decode and install provisioning profile
          PROFILE_PATH=$RUNNER_TEMP/profile.mobileprovision
          echo -n "$PROVISIONING_PROFILE_BASE64" | base64 --decode -o $PROFILE_PATH
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          PROFILE_UUID=$(security cms -D -i $PROFILE_PATH | grep -A1 UUID | grep string | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
          cp $PROFILE_PATH ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision

          # Export for later cleanup
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV

      - name: Restore perushim notes SQLite for iOS ODR asset catalog
        if: ${{ inputs.perushim_notes_sqlite_artifact != '' }}
        id: restore_perushim_ios
        continue-on-error: true
        uses: actions/download-artifact@v7
        with:
          name: ${{ inputs.perushim_notes_sqlite_artifact }}
          path: ${{ env.APP_DIRECTORY }}/BibleOnSite/${{ env.PERUSHIM_NOTES_IOS_ODR_DATASET_RELDIR }}

      - name: Decompress perushim notes for iOS ODR (fallback)
        if: ${{ inputs.perushim_notes_sqlite_artifact == '' || steps.restore_perushim_ios.outcome == 'failure' }}
        working-directory: ${{ env.APP_DIRECTORY }}/BibleOnSite
        run: |
          GZ_FILE="${{ env.PERUSHIM_NOTES_ANDROID_ASSET_RELDIR }}/${{ env.PERUSHIM_NOTES_SQLITE_FILENAME }}.gz"
          DEST_DIR="${{ env.PERUSHIM_NOTES_IOS_ODR_DATASET_RELDIR }}"
          DEST_FILE="$DEST_DIR/${{ env.PERUSHIM_NOTES_SQLITE_FILENAME }}"
          if [ -f "$GZ_FILE" ] && [ ! -f "$DEST_FILE" ]; then
            mkdir -p "$DEST_DIR"
            gunzip -c "$GZ_FILE" > "$DEST_FILE"
            echo "::warning::Using .gz fallback — SQLite artifact not available"
            echo "Decompressed perushim notes for iOS ODR ($(du -h "$DEST_FILE" | cut -f1))"
          else
            echo "Perushim notes already decompressed or .gz not found — skipping"
          fi

      - name: Restore dotnet tools
        working-directory: ${{ env.APP_DIRECTORY }}
        run: dotnet tool restore

      - name: Package IPA
        working-directory: ${{ env.APP_DIRECTORY }}
        run: |
          dotnet run --project devops -- Package --platform iOS --configuration Release \
            --ios-team-id "${{ secrets.IOS_TEAM_ID }}"

      - name: Set artifact name output
        id: set_artifact_name
        run: echo "artifact_name=app-ios-v${{ steps.get_version.outputs.VERSION }}" >> $GITHUB_OUTPUT

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.set_artifact_name.outputs.artifact_name }}
          path: ${{ env.APP_DIRECTORY }}/.artifacts/*.ipa
          retention-days: 30
          if-no-files-found: error
          include-hidden-files: true

      - name: Cleanup signing
        if: always()
        run: |
          # Delete keychain
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain $KEYCHAIN_PATH || true
          fi
          # Delete provisioning profile
          if [ -n "$PROFILE_UUID" ]; then
            rm -f ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision || true
          fi
          # Delete temp files
          rm -f $RUNNER_TEMP/certificate.p12 || true
          rm -f $RUNNER_TEMP/profile.mobileprovision || true

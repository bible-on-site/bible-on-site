name: Shared Release Flow
on:
  workflow_call:
    inputs:
      module_name:
        description: Short module name (website, api, app)
        required: true
        type: string
      module_directory:
        description: Module directory path (e.g., web/bible-on-site, web/api, app)
        required: true
        type: string
      module_version:
        description: The version of the module
        required: true
        type: string
      artifacts_json:
        description: |
          JSON array of artifacts to download and attach to the release.
          Each artifact object should have:
            - name: artifact name to download (empty names are skipped)
            - path: directory to download artifact to
            - glob: file pattern for release attachment
            - label: (optional) human-readable label for release notes
            - cd_key: (optional) key name for CD payload, defaults to artifact name
          Example: [{"name": "my-artifact", "path": ".artifacts", "glob": "**/*.zip", "label": "Windows", "cd_key": "windows_artifact_name"}]
        required: true
        type: string
      cd_event_type:
        description: Event type for the CD workflow trigger (e.g., deploy-aws, deploy-app)
        required: true
        type: string
    outputs:
      released:
        description: Whether the module was successfully released (for version bump coordination)
        value: ${{ jobs.release.outputs.released }}
    secrets:
      DEPLOY_KEY:
        required: true
      BOT_PAT:
        required: true

permissions:
  contents: write

jobs:
  trigger_cd:
    name: Trigger CD Workflow
    runs-on: ubuntu-latest
    steps:
      - name: Build CD Payload
        id: build_payload
        run: |
          ARTIFACTS='${{ inputs.artifacts_json }}'

          # Start with base payload
          PAYLOAD=$(jq -n \
            --arg ref "${{ github.ref }}" \
            --arg module_name "${{ inputs.module_name }}" \
            --arg module_directory "${{ inputs.module_directory }}" \
            --arg module_version "${{ inputs.module_version }}" \
            --arg ci_run_id "${{ github.run_id }}" \
            '{ref: $ref, module_name: $module_name, module_directory: $module_directory, module_version: $module_version, ci_run_id: $ci_run_id}')

          # Add artifact names to payload using cd_key or default key
          while read -r artifact; do
            NAME=$(echo "$artifact" | jq -r '.name // empty')
            CD_KEY=$(echo "$artifact" | jq -r '.cd_key // empty')

            # Skip empty artifacts
            if [ -z "$NAME" ] || [ "$NAME" = "null" ]; then
              continue
            fi

            # Use cd_key if provided, otherwise use a sanitized version of the name or "released_artifact_name" as default
            if [ -z "$CD_KEY" ] || [ "$CD_KEY" = "null" ]; then
              # For single artifact releases, use "released_artifact_name"
              ARTIFACT_COUNT=$(echo "$ARTIFACTS" | jq '[.[] | select(.name != null and .name != "")] | length')
              if [ "$ARTIFACT_COUNT" -eq 1 ]; then
                CD_KEY="released_artifact_name"
              else
                # Sanitize name: replace dashes/dots with underscores
                CD_KEY=$(echo "$NAME" | sed 's/[-.]/_/g')
              fi
            fi

            PAYLOAD=$(echo "$PAYLOAD" | jq --arg key "$CD_KEY" --arg val "$NAME" '. + {($key): $val}')
          done < <(echo "$ARTIFACTS" | jq -c '.[]')

          echo "CD_PAYLOAD=$PAYLOAD" >> $GITHUB_OUTPUT
          echo "Generated CD payload: $PAYLOAD"

      - name: Trigger CD Workflow
        uses: peter-evans/repository-dispatch@v4
        with:
          repository: ${{ github.repository }}
          token: ${{ secrets.BOT_PAT }}
          event-type: ${{ inputs.cd_event_type }}
          client-payload: ${{ steps.build_payload.outputs.CD_PAYLOAD }}

  release:
    name: Release
    outputs:
      released: ${{ steps.mark_released.outputs.released }}
    # Ensures only one release job runs at a time for this module.
    # This prevents potential race conditions which has been proven to occur.
    concurrency:
      group: ${{ github.repository }}-release-${{ inputs.module_name }}
      cancel-in-progress: true
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Create Tag
        id: create_tag
        run: |
          TAG_NAME="${{ inputs.module_name }}-v${{ inputs.module_version }}"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          echo "TAG_NAME=${TAG_NAME}" >> $GITHUB_OUTPUT

      - name: Add Deploy Key
        uses: webfactory/ssh-agent@72c0bfd31ab22a2e11716951e3f107a9647dc97e
        with:
          ssh-private-key: ${{ secrets.DEPLOY_KEY }}

      - name: Push Tag
        run: |
          git remote set-url origin git@github.com:${{ github.repository }}
          git push origin ${{ steps.create_tag.outputs.TAG_NAME }}

      - name: Download Artifacts
        run: |
          set -e

          ARTIFACTS='${{ inputs.artifacts_json }}'
          echo "Processing artifacts: $ARTIFACTS"

          # Process each artifact using gh CLI for precise control
          echo "$ARTIFACTS" | jq -c '.[]' | while read -r artifact; do
            NAME=$(echo "$artifact" | jq -r '.name // empty')
            PATH_DIR=$(echo "$artifact" | jq -r '.path')

            # Skip if artifact name is empty or null
            if [ -z "$NAME" ] || [ "$NAME" = "null" ]; then
              echo "Skipping artifact with empty name"
              continue
            fi

            echo "Downloading artifact '$NAME' to '$PATH_DIR'"
            mkdir -p "$PATH_DIR"

            # Download artifact using gh CLI
            gh run download ${{ github.run_id }} --name "$NAME" --dir "$PATH_DIR" || {
              echo "Warning: Failed to download artifact '$NAME', it may not exist"
            }

            echo "Contents of $PATH_DIR:"
            ls -la "$PATH_DIR" 2>/dev/null || echo "  (empty or not found)"
          done

      - name: Prepare Release
        id: prepare_release
        run: |
          set -e

          ARTIFACTS='${{ inputs.artifacts_json }}'
          MODULE_NAME_CAP="$(echo '${{ inputs.module_name }}' | awk '{print toupper(substr($0,1,1)) substr($0,2)}')"

          # Build file patterns for release
          FILE_PATTERNS=$(echo "$ARTIFACTS" | jq -r '.[] | select(.name != null and .name != "" and .glob != null) | "\(.path)/\(.glob)"')

          echo "FILE_PATTERNS<<EOF" >> $GITHUB_OUTPUT
          echo "$FILE_PATTERNS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Build release body dynamically
          # Check if any artifacts have labels (indicating multi-artifact release)
          HAS_LABELS=$(echo "$ARTIFACTS" | jq '[.[] | select(.label != null and .label != "")] | length')

          if [ "$HAS_LABELS" -gt 0 ]; then
            # Multi-artifact release with download section
            BODY="Automated release for ${MODULE_NAME_CAP} version ${{ inputs.module_version }}."
            BODY="${BODY}"$'\n\n'"## Downloads"

            while read -r artifact; do
              NAME=$(echo "$artifact" | jq -r '.name // empty')
              LABEL=$(echo "$artifact" | jq -r '.label // empty')

              if [ -n "$NAME" ] && [ "$NAME" != "null" ] && [ -n "$LABEL" ] && [ "$LABEL" != "null" ]; then
                BODY="${BODY}"$'\n'"- **${LABEL}**"
              fi
            done < <(echo "$ARTIFACTS" | jq -c '.[]')
          else
            # Simple single-artifact release
            BODY="Automated release for ${MODULE_NAME_CAP} version ${{ inputs.module_version }}."
          fi

          echo "BODY<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "MODULE_NAME_CAP=$MODULE_NAME_CAP" >> $GITHUB_OUTPUT

          echo "File patterns:"
          echo "$FILE_PATTERNS"
          echo ""
          echo "Release body:"
          echo "$BODY"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.create_tag.outputs.TAG_NAME }}
          name: Release ${{ steps.prepare_release.outputs.MODULE_NAME_CAP }} v${{ inputs.module_version }}
          body: ${{ steps.prepare_release.outputs.BODY }}
          token: ${{ secrets.GITHUB_TOKEN }}
          files: ${{ steps.prepare_release.outputs.FILE_PATTERNS }}

      # Note: Version bump is handled by the centralized bump_versions job in ci.yml
      # to avoid race conditions when multiple modules are released in parallel
      - name: Mark Release Complete
        id: mark_released
        run: echo "released=true" >> $GITHUB_OUTPUT
